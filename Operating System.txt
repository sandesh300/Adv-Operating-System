                  Progresive Education Society's
		  Modern College  (Autonomous) Pune-5
		  M.Sc. Computer Science - 2021-22
		  
----------------------------------------------------------------------------------------------------------------------------------------------
             SUBJECT - Advanced Operating System (AOS) 
             Assignment - AOS Practical Questions
	  
----------------------------------------------------------------------------------------------------------------------------------------------
            Name: Bhujbal Sandesh Prakash
            Enrollment no: 2101958
		  
----------------------------------------------------------------------------------------------------------------------------------------------

Q.1)
/* To create 'n' children. When the children will terminate, display total cumulative time children spent in user and kernel mode. */

#include<stdio.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<unistd.h>
#include<time.h>
#include<sys/times.h>
#include<stdlib.h>

int main(void)
{
	int i,status;
	pid_t pid;
	time_t currentTime;
	struct tms cpuTime;
	
	if((pid = fork())== -1)
	{
		perror("fork error");
		exit(EXIT_FAILURE);
       	}
	else if(pid==0)
		{
			time(&currentTime);
			printf("Child proccess started at %s",ctime(&currentTime));
			for(i=0;i< 5; ++i)
			{
				printf("Counting: %d \n",i);
				sleep(i);
			}
			time(&currentTime);
			printf("Child Process ended at %s",ctime(&currentTime));
			exit(EXIT_SUCCESS);
		}
	else{
		time(&currentTime);
		printf("Parent process Started at %s",ctime(&currentTime));

		if(wait(&status)== -1)
			perror("wait error");
		if(WIFEXITED(status))
			printf("Child Process ended normally");
		else
			printf("Child Process did not ended normally\n");

		if(times(&cpuTime)<0)
			perror("Times error");
		else {
			printf("Parent process user time = %ld \n",((double) cpuTime.tms_utime)/_SC_CLK_TCK);
			
			printf("Parent process system time = %ld \n",((double) cpuTime.tms_stime)/_SC_CLK_TCK);

			printf("Child process user time = %ld \n",((double) cpuTime.tms_cutime)/_SC_CLK_TCK);

			printf("Child process system time = %ld \n",((double) cpuTime.tms_cstime)/_SC_CLK_TCK);
		}
		time(&currentTime);
		printf("Parent Process ended at %s",ctime(&currentTime));
		exit(EXIT_SUCCESS);
	
	}
}

/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ ./one
Parent process Started at Fri May 28 19:08:16 2022
Child proccess started at Fri May 28 19:08:16 2022
Counting: 0 
Counting: 1 
Counting: 2 
Counting: 3 
Counting: 4 
Child Process ended at Fri May 28 19:08:26 2022
Child Process ended normallyParent process user time = 94642740162689 
Parent process system time = 94642744980800 
Child process user time = 94642744980800 
Child process system time = 94642744980800 
Parent Process ended at Fri May 28 19:08:26 2022
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ 

*/
-----------------------------------------------------------------------------------------------------------------------------
Q.2)
/* To generate parent process to write unnamed pipe and will read from it. */

#include<stdio.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<unistd.h>
#include<time.h>
#include<sys/times.h>
#include<stdlib.h>

int main(void)
{
	int i,status;
	pid_t pid;
	time_t currentTime;
	struct tms cpuTime;
	
	if((pid = fork())== -1)
	{
		perror("fork error");
		exit(EXIT_FAILURE);
       	}
	else if(pid==0)
		{
			time(&currentTime);
			printf("Child proccess started at %s",ctime(&currentTime));
			for(i=0;i< 5; ++i)
			{
				printf("Counting: %d \n",i);
				sleep(i);
			}
			time(&currentTime);
			printf("Child Process ended at %s",ctime(&currentTime));
			exit(EXIT_SUCCESS);
		}
	else{
		time(&currentTime);
		printf("Parent process Started at %s",ctime(&currentTime));

		if(wait(&status)== -1)
			perror("wait error");
		if(WIFEXITED(status))
			printf("Child Process ended normally");
		else
			printf("Child Process did not ended normally\n");

		if(times(&cpuTime)<0)
			perror("Times error");
		else {
			printf("Parent process user time = %ld \n",((double) cpuTime.tms_utime)/_SC_CLK_TCK);
			
			printf("Parent process system time = %ld \n",((double) cpuTime.tms_stime)/_SC_CLK_TCK);

			printf("Child process user time = %ld \n",((double) cpuTime.tms_cutime)/_SC_CLK_TCK);

			printf("Child process system time = %ld \n",((double) cpuTime.tms_cstime)/_SC_CLK_TCK);
		}
		time(&currentTime);
		printf("Parent Process ended at %s",ctime(&currentTime));
		exit(EXIT_SUCCESS);
	
	}
}
/*
lenovo@lenovo-VirtualBox:~/Documents/AOS$ ./a.out
Parent process Started at Sat May 28 18:44:19 2022
Child proccess started at Sat May 28 18:44:19 2022
Counting: 0 
Counting: 1 
Counting: 2 
Counting: 3 
Counting: 4 
Child Process ended at Sat May 28 18:44:29 2022
Child Process ended normallyParent process user time = 93921686728833 
Parent process system time = 93921691014464 
Child process user time = 93921691014464 
Child process system time = 93921691014464 
Parent Process ended at Sat May 28 18:44:29 2022
*/

------------------------------------------------------------------------------------------------------------------------
Q.3)
/* to create a file with a hole in it */
#include<stdio.h>
#include<fcntl.h>
#include"string.h"

int main()
{
    
    
    int n=creat("file.txt",0777); 
    
    char ch[16]="hello world how are";
    char str[20]="od -c file.txt";
  

    system("chmod 777 file.txt");

        

   write(n,ch,16);

     

    lseek(n,48,SEEK_SET);
       

  write(n,ch,16);
    
    system(str);
    return(0);
}

/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ ./hole 
0000000   h   e   l   l   o       w   o   r   l   d       h   o   w    
0000020  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
*
0000060   h   e   l   l   o       w   o   r   l   d       h   o   w    
0000100

here \0 are holes
*/
--------------------------------------------------------------------------------------------------------------------------------
Q.4)
/* Takes multiple files as command line arguments and print their inode number */
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
int main (int argc, char *argv[])
{
    struct stat fileStat;
    int fd=0,i;
    FILE *filename;


    for(i=0;i<argc;i++)
    {
          filename = argv[i];

          if ( ( fd = open (filename , O_RDONLY) ) == -1)
          {
                perror ( "open " );
                system("pause");
                exit (1) ;
          }

          if(fstat(fd, &fileStat)<0) return 1;

    
          printf("Inode for %s\n",filename);
          printf("---------------------------\n");
          //printf("File Size: \t\t%d bytes\n",fileStat.st_size);
          //printf("Number of Links: \t%d\n",fileStat.st_nlink);
          printf("File inode: \t\t%d\n\n",fileStat.st_ino);

     }    
     //printf("\n%d\n",argc);
     //printf("\n%s\n",argv[0]);
    return 0;
}

/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS/Assignments$ gcc q4.c -o findinode

lenovo@lenovo-VirtualBox:~/Desktop/AOS/Assignments$ ./findinode file.txt file2.txt
Inode for ./findinode
---------------------------
File inode: 		584627

Inode for file.txt
---------------------------
File inode: 		585715

Inode for file2.txt
---------------------------
File inode: 		585720

*/
----------------------------------------------------------------------------------------------------------------------------------
Q.5)
/* To handle the two-way communication between parent and child using pipe. */

#include<stdio.h>
#include<unistd.h>

int main()
{
	int pipefds1[2],pipefds2[2];
	int returnstatus1, returnstatus2;
	int pid;
	char pipe1writemessage[20]="Good";
	char pipe2writemessage[20]="Nice";
	char readmessage[20];
	returnstatus1=pipe(pipefds1);

	if(returnstatus1 == -1)
	{
		printf("Unable to create pipe 1\n");
		return 1;
	}
	returnstatus2 = pipe(pipefds2);

	if(returnstatus2 == -1)
	{
		printf("Unable to create pipe 2 \n");
		return 1;
	}

	pid=fork();

	if(pid!=0)
	{
		close(pipefds1[0]);
		close(pipefds2[1]);
		printf("In Parent : Writing to pipe 1 - Message is %s \n",pipe1writemessage);
		write(pipefds1[1],pipe1writemessage,sizeof(pipe1writemessage));
		read(pipefds2[0],readmessage,sizeof(readmessage));
		printf("In Parent: Reading from pipe 1 - Message is %s \n",readmessage);
	}
	else
	{
		close(pipefds1[1]);
		close(pipefds2[0]);
		read(pipefds1[0],readmessage,sizeof(readmessage));
		printf("In child: Reading from pipe 1 - Message is %s \n",readmessage);
		printf("In child: Writing to pipe 2 -Message is %s \n",pipe2writemessage);
		write(pipefds2[1],pipe2writemessage,sizeof(pipe2writemessage));
	}
	return 0;
}

/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ cc q5.c -o five
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ ./five
In Parent : Writing to pipe 1 - Message is Good 
In child: Reading from pipe 1 - Message is Good 
In child: Writing to pipe 2 -Message is Nice 
In Parent: Reading from pipe 1 - Message is Nice 

*/
------------------------------------------------------------------------------------------------------------------------------
Q.6)
/* Print the type of file where file name accepted through Command Line. */
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<sys/types.h>
#include<sys/stat.h>

int main(int argc,char *argv[])
{
	struct stat fileStat;
	int inode;
	int fd;
	int i;

	if(argc < 2)
	{
		fprintf(stderr,"usage: %s <file>\n",argv[0]);
		return 1;
	}
	else
	{
		printf("cc=%d\t%s",argc,argv[2]);
		for(i=0;i<argc;i++)
		{
			fd=open(argv[i],O_RDONLY);
			if(fd == -1)
			{
				perror("open");
				return 1;
			}
			if(fstat(fd,&fileStat)<0)return 1;
			else
			{
				printf("Information for %s\n",argv[i]);
				printf("---------------\n");
				printf("Type of file:\t%d\n",fileStat.st_mode);
	                }
		}
	}

}
/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ cc q6.c -o file1
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ ./file1
usage: ./file1 <file>

*/
---------------------------------------------------------------------------------------------------------------
Q.7)
/* To demonstate the use of atexit() function */ 
#include <stdio.h>
#include <stdlib.h>

void out (void)
{
    printf ("atexit() succeeded!\n");
}
int main (void)
{
    if (atexit (out))
        fprintf(stderr, "atexit() failed!\n");
    return 0;
}

/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ ./a.out
atexit() succeeded!

*/
------------------------------------------------------------------------------------------------------------
Q.8)
/* Open a file goes to sleep for 15 seconds before terminating. */
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<sys/types.h>
#include<sys/stat.h>

int main()
{
	char fnm[20];
	int fp;
	struct stat st;
	printf("\n Enter the filename :");
	scanf("%s",fnm);

	fp=open(fnm,O_RDONLY);
	if(fp < 0)
	     printf("\n File openinng error");
	else
	{
	     sleep(15);
		
	}
	close(fp);

}
/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ ./eight

 Enter the filename :q7.c
*/
--------------------------------------------------------------------------------------------------------------
Q.9)
/* To print the size of the file */
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
int main (int argc, char *argv[])
{
    struct stat fileStat;
    int fd=0;
    FILE *filename;
    
    filename = (FILE *)argv[1];
    //printf("\n%s\n",argv[1]);

    if ( ( fd = open (filename , O_RDONLY) ) == -1)
    {
         perror ("open ");
         system("pause");
         exit (1) ;
    }

    if(fstat(fd, &fileStat)<0) return 1;
    printf("File Size: \t\t%d bytes\n",fileStat.st_size);
    printf("Mode: \t\t%d\n",fileStat.st_mode);
    return 0;
}
/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ gcc q8.c -o filesize

lenovo@lenovo-VirtualBox:~/Desktop/AOS $ ./filesize file.txt
File Size: 		24 bytes

*/
----------------------------------------------------------------------------------------------------------
Q.10)
/* Read the current directory and display the names of files , no of files in the current directory */
#include <stdio.h>
#include <dirent.h>
int main()
{ 
      struct dirent *de;  //pointer to directory entry
      DIR *dr = opendir("."); //open current directory
      int cnt = 0;
      if(dr == NULL)  // check if directory not exist
      {
           printf("Cannot open a file \n");
           return 0;
      }
      printf("Files in current Directory :\n");
      while((de = readdir(dr))!= NULL )
      {
           printf("%s \n", de->d_name);
           cnt++; 
      }
      printf("\nTotal Number of Files in current directory : %d\n",cnt);
      return 1;
}
/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ gcc q10.c -o name_and_nofiles
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ ./name_and_nofiles
Files in current Directory :
abc.txt 
.. 
q7.c 
filesize 
q1.c 
file.txt 
q2.c 
name_and_nofiles 
q3.c 
findinode 
q10.c 
. 
q6.c 

Total Number of Files in current directory : 13

*/
-------------------------------------------------------------------------------------------------
Q.11)
/* Write a C program to implement the following unix/linux command (use fork, pipe and exec system call) */


#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

int main(int argc,char** argv)
{
	int des_p[2];
	if(pipe(des_p) == -1)
	{
		perror("Pipe Failed");
		exit(1);
	}
	if(fork()==0)
	{
		close(STDOUT_FILENO);
		dup(des_p[1]);
		close(des_p[0]);
		close(des_p[1]);

		const char* progl[] = {"ls","-l",0};
		execvp(progl[0],progl);
		perror("execvp of ls failed");
		exit(1);
	}

	if(fork()==0)
	{
		close(STDIN_FILENO);
		dup(des_p[0]);
		close(des_p[1]);
		close(des_p[0]);

		const char* prog2[] = {"wc","-l",0};
		execvp(prog2[0],prog2);
		perror("execvp of wc failed");
		exit(1);
	}

}
/*
lenovo@lenovo-VirtualBox:~/Documents/AOS$ 47
*/
---------------------------------------------------------------------------------------------------
Q.12)
/* Write a C program to display all the files from current directory which are created in particular month */
#include<stdio.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
#include<dirent.h>
#include<string.h>
#include<time.h>


int main(void)
{
	struct dirent *de;
	struct stat filestat;
	char dirnm[80];

	strcpy(dirnm,getcwd(dirnm,sizeof(dirnm)));
	char mn[20];
	printf("\n Enter the month: ");
	scanf("%s",&mn);
	printf("\n Current Dir = %s\n",dirnm);
	DIR *dr = opendir(dirnm);

	if(dr==NULL)
	{
		printf("Could not open current Directory");
		return 0;
	}
	printf("Files created in the month if %s are : \n",mn);

	while((de = readdir(dr)) != NULL)
	{
		if(stat(de->d_name,&filestat)<0)
			printf("Error");
		else
		{
			//printf("%s",ctime(&filestat.st_mtime));
			if(strstr(ctime(&filestat.st_mtime),mn))
				printf("%s\n",de->d_name);
		}
	}
	closedir(dr);
	return 0;

}
/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS $ ./twelve

 Enter the month: May

 Current Dir = /home/lenovo/Desktop/AOS 
Files created in the month if May are : 
q11.c
file2.txt
q20.c
a.out
..
twelve
q5.c
q9.c
q2.c
eleven
q16.c
filesize
q7.c
thirteen
q13.c
q3.c
six
nine
hole
q4.c
file.txt
q12.c
q6.c
five
q1.c
name_and_nofiles
q8.c
q17.c
findinode
q10.c
.
eight
one
q15.c
*/
-----------------------------------------------------------------------------------------------------------------------
Q.13)
/* Write a C program to display all the files from current directory whose size is greater that n Bytes Where n is accepted from user */
#include<stdio.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
#include<dirent.h>
#include<string.h>

int main(void)
{
	struct dirent *de;
	struct stat filestat;
	char dirnm[80];
	int sz;

	printf("Enter how many bytes :");
	scanf("%d",&sz);

	strcpy(dirnm,getcwd(dirnm,sizeof(dirnm)));
	printf("\n Current Dir = %s\n",dirnm);
	DIR *dr = opendir(dirnm);

	if(dr==NULL)
	{
		printf("Could not open current Directory \n");
		return 0;
	}
	printf("Files are : \n");
	while((de = readdir(dr)) != NULL)
	{
		if(stat(de->d_name,&filestat)<0)
			printf("Error");
		else
		{
			printf("%d",&filestat.st_size);
			if((filestat.st_size) > sz)
				printf("%s\n",de->d_name);
		}
	}
	closedir(dr);
	return 0;

}
/*
lenovo@lenovo-VirtualBox:~/Documents/AOS$ ./a.out
Enter how many bytes :12

 Current Dir = /home/lenovo/Documents/AOS
Files are : 
-1257178560sixteen
-1257178560..
-1257178560NPReader.c
-1257178560seventeen
-1257178560name_and_nofiles
-1257178560eighteen
-1257178560q18.c
-1257178560filesize
-1257178560q5.c
-1257178560-1257178560q15.c
-1257178560file2.txt
-1257178560five
-1257178560q6.c
-1257178560a.out
-1257178560q11.c
-1257178560q17.c
-1257178560q12.c
-1257178560q9.c
-1257178560twelve
-1257178560six
-1257178560q19.c
-1257178560nine
-1257178560q1.c
-1257178560q22.c
-1257178560.
-1257178560q2.c
-1257178560q10.c
-1257178560q25.c
-1257178560q26.c
-1257178560q8.c
-1257178560q3.c
-1257178560findinode
-1257178560one
-1257178560twentyone
-1257178560ninteen
-1257178560q13.c
-1257178560thirteen
-1257178560q7.c
-1257178560q21.c
-1257178560twentyfive
-1257178560q4.c
-1257178560eleven
-1257178560eight
-1257178560hole
-1257178560q20.c
-1257178560q16.c
-1257178560file.txt
*/
---------------------------------------------------------------------------------------------------------------------------------------
Q.14)/* Write a C program to implement the following unix/linux command
         ls -l > output.txt              */
#include<stdio.h>
#include<sys/stat.h>
#include<stdlib.h>
#include<unistd.h>

int spwan(char *program, char **arg_list)
{
	pid_t child_pid;
	child_pid=fork();
	if(child_pid!=0)
	{
		return child_pid;
	}
	else
	{
		execvp(program,arg_list);
		fprintf(stderr,"An error occured in execvp");
		abort();
		
	}
}
int main()
{
	char *arg_list[]={"ls","-l","/",NULL};
	spwan("ls",arg_list);
	printf("Done with main program");
	return 0;
}
/*
lenovo@lenovo-VirtualBox:~/Documents/AOS$ ./a.out
Done with main programlenovo@lenovo-VirtualBox:~/Documents/AOS$ total 2097232
lrwxrwxrwx   1 root root          7 May 22 11:53 bin -> usr/bin
drwxr-xr-x   4 root root       4096 May 22 12:11 boot
drwxrwxr-x   2 root root       4096 May 22 11:58 cdrom
drwxr-xr-x  19 root root       4060 May 28 18:42 dev
drwxr-xr-x 131 root root      12288 May 22 12:27 etc
drwxr-xr-x   3 root root       4096 May 22 12:00 home
lrwxrwxrwx   1 root root          7 May 22 11:53 lib -> usr/lib
lrwxrwxrwx   1 root root          9 May 22 11:53 lib32 -> usr/lib32
lrwxrwxrwx   1 root root          9 May 22 11:53 lib64 -> usr/lib64
lrwxrwxrwx   1 root root         10 May 22 11:53 libx32 -> usr/libx32
drwx------   2 root root      16384 May 22 11:52 lost+found
drwxr-xr-x   2 root root       4096 Feb 10  2021 media
drwxr-xr-x   2 root root       4096 Feb 10  2021 mnt
drwxr-xr-x   2 root root       4096 Feb 10  2021 opt
dr-xr-xr-x 240 root root          0 May 28 18:04 proc
drwx------   4 root root       4096 May 22 12:13 root
drwxr-xr-x  31 root root        840 May 28 19:05 run
lrwxrwxrwx   1 root root          8 May 22 11:53 sbin -> usr/sbin
drwxr-xr-x   8 root root       4096 Feb 10  2021 snap
drwxr-xr-x   2 root root       4096 Feb 10  2021 srv
-rw-------   1 root root 2147483648 May 22 11:53 swapfile
dr-xr-xr-x  13 root root          0 May 28 18:04 sys
drwxrwxrwt  19 root root       4096 May 28 19:28 tmp
drwxr-xr-x  14 root root       4096 Feb 10  2021 usr
drwxr-xr-x  14 root root       4096 Feb 10  2021 var

---------------------------------------------------------------------------------------------------------------------------------------
Q.15)
/* Write a c programm  that display information of a given file similar to given by unix/linux
	          ls -l <filename> */

#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
int spawn ( char * program ,char **arg_list )
{
	pid_t child_pid;
	child_pid =fork();
	if ( child_pid !=0 )
	{
		return child_pid;
	}
	else
	{
	execvp ( program ,arg_list );
	fprintf(stderr,"An error occured in execvp");
	abort();
	}	
}

int main ( int argc , char *argv[] )
{
	char * fd =argv[1];
	char *arg_list[]={
		"ls", "-l", fd,
		NULL};
	spawn ("ls" , arg_list);
	printf("%s", fd);
	return 0;
}

/*
null) lenovo@ lenovo-VirtualBox:~/Desktop/AOS $ total 192
drwxrwxr-x 2  lenovo  lenovo  4096 May 24 12:59 25May
-rwxrwxr-x 1  lenovo  lenovo 16992 May 24 16:59 a.out
-rw-rw-r-- 1  lenovo  lenovo    17 May 15 10:09 file2.txt
-rwxrwxr-x 1  lenovo  lenovo 17024 May 15 11:49 filesize
-rwxrwxrwx 1  lenovo  lenovo    64 May 24 15:45 file.txt
-rwxrwxr-x 1  lenovo  lenovo 17064 May 15 10:35 findinode
-rwxrwxr-x 1  lenovo  lenovo 16880 May 24 14:34 hole
-rwxrwxr-x 1  lenovo  lenovo 16832 May 15 13:22 name_and_nofiles
-rwxrwxr-x 1  lenovo  lenovo 17024 May 15 15:12 nine
-rw-rw-r-- 1  lenovo  lenovo  1016 May 15 13:25 q10.c
-rw-rw-r-- 1  lenovo  lenovo     0 May 15 14:22 q12.c
-rw-rw-r-- 1  lenovo  lenovo   905 May 15 14:44 q13.c
-rw-rw-r-- 1  lenovo  lenovo   943 May 24 16:59 q15.c
-rw-rw-r-- 1  lenovo  lenovo     0 May 15 14:22 q16.c
-rw-rw-r-- 1  lenovo  lenovo     0 May 15 14:22 q17.c
-rw-rw-r-- 1  lenovo  lenovo  1023 May 22 21:16 q20.c
-rw-rw-r-- 1  lenovo  lenovo   991 May 24 15:44 q3.c
-rw-rw-r-- 1  lenovo  lenovo  1210 May 15 11:58 q4.c
-rw-rw-r-- 1  lenovo  lenovo   551 May 24 14:36 q6.c
-rw-rw-r-- 1  lenovo  lenovo   288 May 24 16:58 q7.c
-rw-rw-r-- 1  lenovo  lenovo   192 May 24 16:50 q8.c
-rw-rw-r-- 1  lenovo  lenovo   735 May 15 15:11 q9.c
-rwxrwxr-x 1  lenovo  lenovo 17024 May 15 15:06 thirteen

*/
-----------------------------------------------------------------------------------------------------------------
Q.16)
/* Write a C program that behaves like a shell (command interpreter). It has its own prompt say “NewShell$”. Any normal shell command is executed from your shell by starting a child process to execute the system program corresponding to the command. It should additionally interpret the following command
i)count c <filename> - print number of characters in file
ii) count w <filename> - print number of words in file
iii)count l <filename> - print number of lines in file
*/

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<sys/stat.h>

int main()
{
	char cmd[80],t1[20],t2[20],t3[20],ch;
	int charcnt=0,linecnt=0,wcnt=0;
	FILE *fp;
	int pid;

	pid=vfork();
	printf("PP = %d",pid);
	if(pid==0)	
	{
		while(1)
		{
			printf("\n NewShell$:");
			gets(cmd);
			sscanf(cmd,"%s %s %s",t1,t2,t3);

			if(strcmp(t1,"count")==0)
			{
				switch(t2[0])
				{
					case 'c' : fp=fopen(t3,"r");
						   while((ch=getc(fp))!=EOF)
					           {
						   	charcnt++;
						   }
						   printf("\n No of chars = %d",charcnt);
						   fclose(fp);
						   break;
				 	case 'l' : fp=fopen(t3,"r");
						   while((ch=getc(fp))!=EOF)
						   {
						   	if(ch=='\n')linecnt++;
						   }
						   printf("\n No of lines = %d",linecnt);
						   fclose(fp);
						   break;
					case 'w' : fp=fopen(t3,"r");
						   while((ch=getc(fp))!=EOF)
						   {
						   	if(ch=='\n' || ch==' ')
								wcnt++;
						   }
						   printf("\n No of words = %d",wcnt);
						   fclose(fp);
						   break;
				 	default : printf("Invalid Choice");
						  break;
				}
			}
			else
			{
				printf("Invalid Option");
				exit(0);
			}
		}
	}
}

/*
 lenovo@ lenovo-VirtualBox:~/Desktop/AOS $ ./sixteen
PP = 0
 NewShell$:count c q1.c

 No of chars = 2139
 NewShell$:count w q1.c

 No of words = 254
 NewShell$:count l q1.c

 No of lines = 84

*/
----------------------------------------------------------------------------------------------------------------------------------------
Q.17)
/* 17. Write a C program that behaves like a shell (command interpreter). It has its own prompt say “NewShell$”. Any normal shell command is executed from your shell by starting a child process to execute the system program corresponding to the command. It should additionally interpret the following command.
i) list f <dirname> - print name of all files in directory
ii) list n <dirname> - print number of all entries
iii) list i<dirname> - print name and inode of all files  */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<fcntl.h>
#include<dirent.h>
int main()
{
    char command[30],cmd[10],dnm[50],op[50],func[50];
    DIR *dp;
    struct dirent *dirf;
    int file,pid,cnt=0;

    while(1)
    {
         printf("\n ---");
         gets(func);
         sscanf(func,"%s %s %s",cmd,op,dnm);
         pid=fork();
         if(pid==0)
         {
                if(strcmp(cmd,"list")==0)
                {
                      if(op[0]=='f')
                      {
                          dp=opendir(dnm);
                          while((dirf=readdir(dp))!=NULL)
                          {
                               printf("\n Name %s",dirf->d_name);
                          }
                         closedir(dp);
                      } 
                      if(op[0]=='n')
                      {
                          cnt=0;
                          dp=opendir(dnm);
                          while((dirf=readdir(dp))!=NULL)
                          {
                               cnt++;
                          }
                          printf("\n Number of files %d",cnt);
                          closedir(dp);
                      }
                      if(op[0]=='i')
                      {
                          dp=opendir(dnm);
                          while((dirf=readdir(dp))!=NULL)
                          {
                               printf("\n File name=%s and inode=%d \n",dirf->d_name,dirf->d_ino);
                          }
                          closedir(dp);
                      } 
                 }
                 else if(strcmp(cmd,"exit")==0)
                 {
                         exit(0);
                 }
            }  
      }
}
/*
 lenovo@ lenovo-VirtualBox:~/Desktop/AOS $ ./seventeen

 ---list f /home

 ---
 Name  lenovo
 Name ..
 Name .
 ---list n /home/

 ---
 Number of files 3
 ---list i /home/   

 ---
 File name= lenovo and inode=398228 

 File name=.. and inode=2 

 File name=. and inode=393218 

 ---

*/
--------------------------------------------------------------------------------------------------------------------------------------
Q.18)
/* Write a C program that behaves like a shell (command interpreter). It has its own prompt say "NewShell$". Any normal shell command is executed from your shell by starting a child process to execute the system
program corresponding to the command. It should additionally interpret the following command.
i) typeline +10 <filename> - print first 10 lines of file
ii) typeline -20 <filename> - print last 20 lines of file
iii) typeline a <filename> - print all lines of file */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<fcntl.h>

int main()
{
	FILE *fp;
	int n,cnt2,cnt=1,flag=0,pid,i=0;
	char func[50],cmd[50],fnm[50],op[50],line[80],buff[80],ch;

	while(1)
	{
		printf("\n New Shell $ # ");
		gets(func);
		sscanf(func,"%s %s %s",cmd,op,fnm);
		if(strcmp(cmd,"typeline")==0)
		{
			fp=open(fnm,O_RDONLY);
			if(fp==-1)
			{
				printf("\n File Not Found");
			}
			else
			{
				if(op[0]=='+')
				{
    					cnt=1;
    					n=atoi(op);
    					printf("\n First %d lines are",n);
    					while(cnt<=n)
    					{
        					read(fp,buff,1);
        					ch=buff[0];
        					printf("%c",ch);
        					if(ch=='\n')
      	 						cnt++;
    					}
    					close(fp);
				}
				else if(op[0]=='a')
					{
    						fp=open(fnm,O_RDONLY);
						while(read(fp,buff,1)!=0)
						{
							ch=buff[0];
							printf("%c",ch);
						}
						close(fp);
					}
					else if(op[0]=='-')
						{
							cnt=0;
							fp=open(fnm,O_RDONLY);
							n=atoi(op);
							printf("Print last %d lines \n",n);
							while(read(fp,buff,1)!=0)
							{
								ch=buff[0];
								if(ch=='\n')
								{
									cnt++;
								}
							}
							cnt2=cnt+n;
							int x=1;
							cnt=0;
							lseek(fp,0,SEEK_SET);
							while(x<=cnt2)
							{
    								read(fp,buff,1);
    								ch=buff[0];
    								if(ch=='\n')
    								{
        								x++;
    								}
							}
							while(read(fp,buff,1)!=0)
							{
    								ch=buff[0];
    								printf("%c",ch);
							}
							close(fp);
						}
			}
		}
	}	
}

/*
 lenovo@lenovo-VirtualBox:~/Documents/AOS$ ./a.out

 New Shell $ # typeline a file.txt             
hello world how hello world how 
 New Shell $ # typeline +10 q1.c

 First 10 lines are


/*
To create â€˜nâ€™ children. When the children will terminate, display total cumulative time children spent in user and kernel mode.
*/

#include<stdio.h>
#include<sys/types.h>
#include<sys/wait.h>

 New Shell $ # typeline -20 q1.c
Print last -20 lines 
}

/*
lenovo@lenovo-VirtualBox:~/Desktop/AOS/Assignment 2$ ./one
Parent process Started at Fri May 27 07:15:16 2022
Child proccess started at Fri May 27 07:15:16 2022
Counting: 0 
Counting: 1 
Counting: 2 
Counting: 3 
Counting: 4 
Child Process ended at Fri May 27 07:15:26 2022
Child Process ended normallyParent process user time = 94642740162689 
Parent process system time = 94642744980800 
Child process user time = 94642744980800 
Child process system time = 94642744980800 
Parent Process ended at Fri May 27 07:15:26 2022
lenovo@lenovo-VirtualBox:~/Desktop/AOS/Assignment 2$ 

*/

 New Shell $ # 


*/
------------------------------------------------------------------------------------------------------------------------------------------------
Q.19)
/* Write a C program that behaves like a shell (command interpreter). It has its own prompt say “NewShell$”.Any normal shell command is executed from your shell by starting a child process to execute the system program corresponding to the command. It should
i) additionally interpret the following command.
ii) search f <pattern> <filename> - search first occurrence of pattern in filename
iii) search c <pattern> <filename> - count no. of occurrences of pattern in filename
iv) search a <pattern> <filename> - search all occurrences of pattern in filename */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<fcntl.h>

int main()
{
      FILE *fp;
      int n,cnt=1,flag=0,pid,i=0;
      char func[50],cmd[50],fnm[50],op[50],pat[50],line[80],buff[80],ch;

      while(1) 
      {

           printf("\n New Shell $ # ");
           gets(func);
           sscanf(func,"%s %s %s %s",cmd,op,pat,fnm);
           pid=fork();
           if(pid==0)
           {
              if(strcmp(cmd,"search")==0)
              {
                  fp=open(fnm,O_RDONLY);
                  if(fp==-1)
                  {
                        printf("\n File Not Found");
                  }
                  else
                  { 
                       if(op[0]=='f')
                       {
                            while(read(fp,buff,1)!=0)
                            {

                                   ch=buff[0];
                                   if(ch!='\n')
                                   {
                                       line[i]=ch;
                                       i++;
                                   }
                                   if(ch=='\n')
                                   { 
                                       line[i]=ch;
                                       if(strstr(line,pat)!=NULL)
                                       {
                                            flag=1;
                                            printf("Pattern found %s cnt=%d",pat,cnt);
                                            break;
                                       }
                                       else
                                       {
                                             flag=0;
                                             cnt++;
                                       }
                                       i=0;
                                    }
                             }
                             if(flag==0)
                             { 
                                   printf("\nPattern not found\n"); 
                             }

                        }          

                        else if(op[0]=='a')
                        {
                             while(read(fp,buff,1)!=0)
                             {
                                  ch=buff[0];
                                  if(ch!='\n')
                                  {
                                       line[i]=ch;
                                       i++;
                                  } 
                                  if(ch=='\n') 
                                  {
                                      if(strstr(line,pat)!=NULL)
                                      {
                                           flag=1;
                                           printf("\n Pattern found %s cnt=%d",pat,cnt);
                                           cnt++;
                                      }
                                      else
                                      {
                                           flag=0;
                                           cnt++;
                                      }
                                      i=0;
                                  } 
                              }
                              if(flag==0)
                              { 
                                     printf("\nPattern not found\n"); 
                              }

                         } 
                         else if(op[0]=='c')
                         {
                               cnt=0;
                               while(read(fp,buff,1)!=0)
                               {
                                     ch=buff[0];
                                     if(ch!='\n')
                                     {
                                           line[i]=ch;
                                           i++;
                                     }
                                     if(ch=='\n')
                                     {
                                           if(strstr(line,pat)!=NULL)
                                           {
                                                flag=1;
                                                cnt++;
                                           }
                                           i=0;
                                     }
                                }
                                printf("\n\n Pattern %s and at cnt=%d",pat,cnt);
                          }
                 }
          }
          else if(strcmp(cmd,'exit')==0)
          {
                exit(0);
          }
      }     
   }
}
/*
 lenovo@lenovo-VirtualBox:~/Documents/AOS$ ./a.out

 New Shell $ # search f main q19.c

 New Shell $ # Pattern found main cnt=17
 New Shell $ # search a include q19.c

 New Shell $ # 
 Pattern found include cnt=11
 Pattern found include cnt=12
 Pattern found include cnt=13
 Pattern found include cnt=14
 Pattern found include cnt=15
 Pattern found include cnt=16
 Pattern found include cnt=146
 Pattern found include cnt=147
 Pattern found include cnt=148
 Pattern found include cnt=149
 Pattern found include cnt=150
Pattern not found

 New Shell $ # search c printf q19.c         

 New Shell $ # 

 Pattern printf and at cnt=40
 New Shell $ # 


*/
-----------------------------------------------------------------------------------------------------------------------------------------
Q.20)
/* Write a C program which recieves file names as command line arguments and display those file names in ascending order according to their sizes 
i)(e.g. $ a.out a.txt b.txt c.txt , ...)  */

#include<stdio.h>
#include<string.h>
#include<sys/stat.h>

//sort file according to size of file
struct list
{
	char fname[20];
	int size;
}l[10];


void main(int argc,char *argv[])
{
	int i=0,j;
	struct stat sbuff;
	struct list temp;
	for(i=1;i<argc;i++)
	{
		stat(argv[i],&sbuff);
		strcpy(l[i-1].fname,argv[i]);
		l[i-1].size=sbuff.st_size;
	}
	
	//bubble sort
	for(i=0;i<argc-1;i++)
	{
		for(j=i+1;j<argc-1;j++)
		{
			if(l[i].size > l[j].size)
			{
				strcpy(temp.fname,l[j].fname);
				temp.size=l[j].size;
				strcpy(l[j].fname,l[i].fname);
				l[j].size=l[i].size;
				strcpy(l[i].fname,temp.fname);
				l[i].size=temp.size;
				
			}
		}
	}
	//printing
	printf("File Name\t File Size\n");
	
	for(i=0;i<argc-1;i++)
	{
		printf("\n%s\t%d",l[i].fname,l[i].size);
	}
	
}
/*
 lenovo@ lenovo-VirtualBox:~/Desktop/AOS/UnixShell/unix$ ./ascendingOrder search_unix.txt mysearchunix.txt dir_inode.txt ls_output_txt.txt
File Name	 File Size

mysearchunix.txt	123
dir_inode.txt	337
search_unix.txt	727
ls_output_txt.txt	1967
*/
----------------------------------------------------------------------------------------------------------------------------------------------
Q.21)
/*Write a C program which create a child process which catch a signal sighup, sigint and sigquit. The Parent process send a sighup or sigint signal after every 3 seconds, at the end of 30 second parent send sigquit signal to child and child terminates my displaying message 
"My DADDY has Killed me!!!.*/

#include <signal.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/types.h> 
#include <unistd.h> 

// function declaration 
void sighup(); 
void sigint(); 
void sigquit(); 

// driver code 
void main() 
{ 
	int pid; 

	/* get child process */
	if ((pid = fork()) < 0) 
	{ 
		perror("fork"); 
		exit(1); 
	} 
	sleep(3);
	if (pid == 0) 
	{	 /* child */
		printf("II:");
		signal(SIGHUP, sighup); 
		signal(SIGINT, sigint); 
		signal(SIGQUIT, sigquit); 
		for (;;); 
		/* loop for ever */
	} 

	else /* parent */
	{ /* pid hold id of child */
		printf("\nPARENT: sending SIGHUP\n\n"); 
		kill(pid, SIGHUP); 

		sleep(3); /* pause for 3 secs */
		printf("\nPARENT: sending SIGINT\n\n"); 
		kill(pid, SIGINT); 

		sleep(3); /* pause for 3 secs */
		printf("\nPARENT: sending SIGQUIT\n\n"); 
		kill(pid, SIGQUIT); 
		sleep(3); 
	} 
} 

// sighup() function definition 
void sighup() 

{ 
	signal(SIGHUP, sighup); /* reset signal */
	printf("CHILD: I have received a SIGHUP\n"); 
} 

// sigint() function definition 
void sigint() 
{ 
	signal(SIGINT, sigint); /* reset signal */
	printf("CHILD: I have received a SIGINT\n"); 
} 

// sigquit() function definition 
void sigquit() 
{ 
	printf("My DADDY has Killed me!!!\n"); 
	exit(0); 
} 

/*
lenovo@lenovo-VirtualBox:~/Documents/AOS$ ./a.out

PARENT: sending SIGHUP


PARENT: sending SIGINT


PARENT: sending SIGQUIT


*/
-----------------------------------------------------------------------------------------------------------------------------
Q.22)
/*Write a C program to implement the following unix/linux command (use fork, pipe and exec system call). Your program should block the signal Ctrl-C and Ctrl-\signal during the execution. ls –l | wc –l*/

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main(void)
{
    int fd[2];
    pid_t pid1, pid2;

    if (pipe(fd) < 0)
        perror("pipe error"), exit(1);
    else if ((pid1 = fork()) < 0)
        perror("fork error"), exit(1);
    else if (pid1 == 0)
    {
        /* ls */
        dup2(fd[1], STDOUT_FILENO);
        close(fd[0]);
        close(fd[1]);
        execlp("ls", "ls", (char *)0);
        perror("exec ls");
        exit(1);
    }
    else if ((pid2 = fork()) < 0)
        perror("fork error"), exit(1);
    else if (pid2 == 0)
    {
        /* wc */
        dup2(fd[0], STDIN_FILENO);
        close(fd[0]);
        close(fd[1]);
        execlp("wc", "wc", (char *)0);
        perror("exec wc");
        exit(1);
    }
    else
    {
        close(fd[0]);
        close(fd[1]);
        int status1;
        int status2;
        int corpse1 = waitpid(pid1, &status1, 0);
        int corpse2 = waitpid(pid2, &status2, 0);
        printf("ls: pid = %d, corpse = %d, exit status = 0x%.4X\n", pid1, corpse1, status1);
        printf("ls: pid = %d, corpse = %d, exit status = 0x%.4X\n", pid2, corpse2, status2);
    }
    return 0;
}

/*
/tmp/SxuczQpB8V.o
0       0       0
ls: pid = 10746, corpse = 10746, exit status = 0x0000
ls: pid = 10747, corpse = 10747, exit status = 0x0000
*/
-----------------------------------------------------------------------------------------------------------------------------
Q.23) /*Write a C Program that demonstrates redirection of standard output to a file.*/
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
void main(int argc, char *argv[])
{
	char d[50];
 	if(argc==2)
	{
		bzero(d,sizeof(d));
		strcat(d,"ls ");
		strcat(d,"> ");
		strcat(d,argv[1]);
		system(d);
	}
	else
		printf("\nInvalid No. of inputs");
}

/*
lenovo@lenovo-VirtualBox:~/Documents/AOS$ ./q23 file.txt
lenovo@lenovo-VirtualBox:~/Documents/AOS$ cat file.txt
a.out
eight
eighteen
eleven
file2.txt
filesize
file.txt
findinode
firstPipe
five
hole
name_and_nofiles
nine
ninteen
NPR
NPR.c
NPW
NPW.c
NPWriter.c
one
q10.c
q11.c
q12.c
q13.c
q14.c
q15.c
q16.c
q17.c
q18.c
q19.c
q1.c
q20.c
q21.c
q22.c
q23
q23.c
q25.c
q26.c
q2.c
q3.c
q4.c
q5.c
q6.c
q7.c
q8.c
q9.c
seventeen
six
sixteen
thirteen
twelve
twentyfive
twentyone 
-----------------------------------------------------------------------------------------------------------------------------
Q.24)/*Write a program that illustrates how to execute two commands concurrently with a pipe.*/
#include <stdio.h> 
#include <unistd.h> 
#include <sys/types.h> 
#include <stdlib.h> 
int main()
{
int pfds[2];
char buf[30];
if(pipe(pfds)==-1)
{
perror("pipe failed");
exit(1);
}
if(!fork())
{
close(1);
dup(pfds[1]);
system ("ls -l");
}
else
{
printf("parent reading from pipe \n");
while(read(pfds[0],buf,80))
printf("%s \n" ,buf);
}
}

/*
lenovo@lenovo-VirtualBox:~/Documents/AOS$ cc q24.c -o q24
lenovo@lenovo-VirtualBox:~/Documents/AOS$ ./q24
parent reading from pipe total 592
-rwxrwxr-x 1 lenovo lenovo 16840 May 31 21:18 a.out
-rwxrwxr-x 1 lenovo lenovo 16928 May 27 07:35 eight
-rwxrwxr-x 1 lenovo lenovo 17088 May 27  12:33 eighteen
-rwxrwxr-x 1 lenovo lenovo 17000 May 27 07:43 eleven
-rw-rw-r--1 lenovo lenovo    17 May 15 10:09 file2.txt
-rwxrwxr-x 1 lenovo lenovo 170 24 May 15 11:49 filesize
-rwxrwxrwx 1 lenovo lenovo   355 May 31 21:21 file.txt
-rwxrwxr-x 1 lenovo lenovo 17064 May 15 10:35 findinode 
prw-rw---- 1 lenovo lenovo     0 May 28 19:39 first Pipe
-rwxrwxr-x 1 lenovo lenovo 17000 May 27  07:21 five
-rwxrwxr-x 1 lenovo lenovo 16880 May 24 14:34 hole
-rwxrwxr-x 1 lenovo lenovo 16832 May 15 13:22 name_and_nofiles
-rwxrwxr-x 1 lenovo lenovo 17024 May 15 15:12 nine
-rwxrwxr-x 1 lenovo lenovo 17088 May 27 12:53 ninteen
-rwxrwxr-x 1 lenovo lenovo 17064 May 28 19:37 NPR
-rw-rw-r-- 1 lenovo lenovo  375 May 27 20:49 NPR.c
-rwxrwxr-x 1 lenovo lenovo 16952 May 28 19:38 NPW
-rw-rw-r-- 1 lenovo lenovo  306 May 28 19:33 NPW.c
-rw-rw-r-- 1 lenovo lenovo 306 May 28 19:44 NPWriter.c
-rwxrwxr-x 1 lenovo lenovo 17064 May 27 07:15 one
-rw-rw-r-- 1 lenovo lenovo  1016 May 15 13:25 q10.c
-rw-rw-r-- 1 lenovo lenovo   724 May 27 07:42 q11.c
-rw-rw-r-- 1 lenovo lenovo  1337 May 27 07:46 q12.c
-rw-rw-r-- 1 lenovo lenovo   896 May 27 07:59 q13.c
-rw-rw-r-- 1 lenovo lenovo   432 May 28 19:28 q14.c
-rw-rw-r-- 1 lenovo lenovo  1901 May 24 17:00 q15.c
-rw-rw-r-- 1 lenovo lenovo  1860 May 27 12:24 q16.c
-rw-rw-r-- 1 lenovo  lenovo  2575 May 27 12:31 q17.c
-rw-rw-r-- 1 lenovo lenovo  4971 May 27 12:39 q18.c
-rw-rw-r-- 1 lenovo lenovo  6115 May 27 12:55 q19.c
-rw-rw-r-- 1 lenovo lenovo  2142 May 28 18:35 q1.c
-rw-rw-r-- 1 lenovo lenovo  1023 May 24 17:02 q20.c
-rw-rw-r-- 1 lenovo lenovo  1771 May 27 13:03 q21.c
-rw-rw-r-- 1 lenovo lenovo   227 May 27 17:02 q22.c
-rwxrwxr-x 1 lenovo lenovo 16840 May 31 21:19 q23
-rw-rw-r-- 1 lenovo lenovo   467 May 31 21:16 q23.c
-rwxrwxr-x 1 lenovo lenovo 17128 May 31 21:26 q24
-rw-rw-r-- 1 lenovo lenovo   360 May 31 21:25 q24.c
-rw-rw-r-- 1 lenovo lenovo  1144 May 27 17:09 q25.c
-rw-rw-r-- 1 lenovo lenovo   306 May 27 20:57 q26.c
-rw-rw-r-- 1 lenovo lenovo  1496 May 27 07:16 q2.c
-rw-rw-r-- 1 lenovo lenovo   991 May 24 15:44 q3.c
-rw-rw-r-- 1 lenovo lenovo  1210 May 15 11:58 q4.c
-rw-rw-r-- 1 lenovo lenovo  1549 May 27 07:22 q5.c
-rw-rw-r-- 1 lenovo lenovo   869 May 27 07:27 q6.c
-rw-rw-r-- 1 lenovo lenovo   288 May 24 17:17 q7.c
-rw-rw-r-- 1 lenovo lenovo   574 May 27 07:41 q8.c
-rw-rw-r-- 1 lenovo lenovo   735 May 15 15:11 q9.c
-rwxrwxr-x 1 lenovo lenovo 17056 May 27 12:30 seventeen
-rwxrwxr-x 1 lenovo lenovo 17048 May 27  07:27 six
-rwxrwxr-x 1 lenovo lenovo 17096 May 27 12:24 sixteen 
-rwxrwxr-x 1 lenovo lenovo 17168 May 27 07:58 thirteen
-rwxrwxr-x 1 lenovo lenovo 17248 May 27 07:46 twelve
-rwxrwxr-x 1 lenovo lenovo 16824 May 27 17:09 twentyfive
-rwxrwxr-x 1 lenovo lenovo 17088 May 27 13:00 twentyone 
-----------------------------------------------------------------------------------------------------------------------------
Q.25)
/* Write a C program that illustrates suspending and resuming processes using signals. */

#include <signal.h>
#include <stdio.h>
int main ()
{
      int pid1;
      int pid2;
      pid1 = fork();
      if (pid1 == 0) /* First child */
      {
          while (1) /* Infinite loop */
          {
               printf ("pid1 is alive\n");
               sleep (1);
          }
      }
      pid2 = fork (); /* Second child */
      if (pid2 == 0)
      {
          while (1) /* Infinite loop */
          {
               printf ("pid2 is alive\n");
               sleep (1);
          }
      }
      sleep (3);
      kill (pid1, SIGSTOP); /* Suspend first child */
      sleep (3);
      kill (pid1, SIGCONT); /* Resume first child */
      sleep (3);
      kill (pid1, SIGINT); /* Kill first child */
      kill (pid2, SIGINT); /* Kill second child */
}
/*
lenovo@lenovo-VirtualBox:~/Documents/AOS$ ./a.out
pid1 is alive
pid2 is alive
pid1 is alive
pid2 is alive
pid2 is alive
pid1 is alive
pid2 is alive
pid2 is alive
pid2 is alive
pid1 is alive
pid2 is alive
pid1 is alive
pid2 is alive
pid1 is alive
pid2 is alive
*/
----------------------------------------------------------------------------------------------------------------------
Q.26)
/*Write a C program that illustrates inters process communication using shared memory*/

#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
Struct country
{
       Char name[30];
       Char capital_city[30];
       Char currency[30];
       Int population;
};
Int main(int argc, char *argv[])
{
       Int shm_id;
       Char *shm_addr;
       Int *countries_num;
       Struct country *countries;
       Struct shmid_ds shm_desc;
       Shm_id = shmget(100, 2048, IPC_CREAT | IPC_EXCL\0600);
       If(shm_id == -1)
       {
              Perror(“main:shmget
                     :”);
              Exit(1);
       }
       Shm_addr = shmat(shm_id, NULL, 0);
       If(!shm_addr)
       {
              Perror(“main:shmat
                     :”);
              Exit(1);
       }
       Countries_num = (int *)shm_addr;
       *countries_num = 0;
       Countries = (struct country *)((void *)shm_addr sizeof(int));
       Strcpy(countries[0], name,”U.S.A”);
       Strcpy(countries[0], capital_city,”WASHINGTON”);
       Strcpy(countries[0], currency,”U.S.DOLLAR”);
       Countries[0].population = 250000000;
       (countries_num);
       Strcpy(countries[1].name,”israel”);
       Strcpy(countries[1].capital_city,”jerushalem”);
       Strcpy(countries[1].currency,”NEW ISRAEL SHEKED”);
       Countries[1].population = 6000000;
       (*countries_num);
       Strcpy(countries[2].name,”France”);
       Strcpy(countries[2].capital_city,”paris”);
       Strcpy(countries[2].currency,”Frank”);
       Countries[2].population = 60000000;
       (*countries_num);
       For(i = 0; i < (*countries_num); i)
       {
              Printf(“country % d
                     :\n”, i 1);
              Printf(“name
                     : % d
                     :\n”, i 1);
              Printf(“currency
                     : % s
                     :\n”, countries[i].currency);
              Printf(“population
                     : % d
                     :\n”, countries[i].population);
       }
       If(shmdt(shm_addr) == -1)
       {
              Perror(“main:shmdt
                     :”);
       }
       If(shmctl(shm_id, IPC_RMID, &SHM_DESC) == -1)
       {
              Perror(“main:shmctl
                     :”);
       }
       return 0;
}


/*

lenovo@lenovo-VirtualBox:~/Documents/AOS$ gcc shm.c
lenovo@lenovo-VirtualBox:~/Documents/AOS$ ./a.out
Shared memory ID=65537 child pointer 3086680064
Child value =1
Shared memory ID=65537 child pointer 3086680064
Parent value=1
Parent value=42
Child value=42
*/



